漫谈五种IO模型（主讲IO多路复用）
https://www.jianshu.com/p/6a6845464770
1.阻塞I/O模型
老李去火车站买票，排队三天买到一张退票。
耗费：在车站吃喝拉撒睡 3天，其他事一件没干。


2.非阻塞I/O模型
老李去火车站买票，隔12小时去火车站问有没有退票，三天后买到一张票。耗费：往返车站6次，路上6小时，其他时间做了好多事。


3.I/O复用模型
1.select/poll
老李去火车站买票，委托黄牛，然后每隔6小时电话黄牛询问，黄牛三天内买到票，然后老李去火车站交钱领票。
耗费：往返车站2次，路上2小时，黄牛手续费100元，打电话17次
2.epoll
老李去火车站买票，委托黄牛，黄牛买到后即通知老李去领，然后老李去火车站交钱领票。
耗费：往返车站2次，路上2小时，黄牛手续费100元，无需打电话


4.信号驱动I/O模型
老李去火车站买票，给售票员留下电话，有票后，售票员电话通知老李，然后老李去火车站交钱领票。
耗费：往返车站2次，路上2小时，免黄牛费100元，无需打电话


5.异步I/O模型
老李去火车站买票，给售票员留下电话，有票后，售票员电话通知老李并快递送票上门。
耗费：往返车站1次，路上1小时，免黄牛费100元，无需打电话

AIO扩展：AIX 操作系统中AIO、DIO、CIO 的相关概念介绍
https://blog.csdn.net/yefengwuhen2012/article/details/8458440

宋宝华： 数据库为什么有可能喜欢Linux AIO（异步I/O）?
http://www.eeworld.com.cn/mp/ymc/a51863.jspx

--------------------------------------------------------分割线-------------------------------------------------------------------------------
两种高性能I/O设计模式(Reactor/Proactor)的比较
https://www.cnblogs.com/pigerhan/p/3532695.html

IO多路复用模式：Reactor和Proactor对比以及优缺点（netty的底层原理reactor模型）
https://blog.csdn.net/wanbf123/article/details/78062802




--------------------------------------------------------分割线-------------------------------------------------------------------------------	
redis为什么选择单线程工作模型
http://www.cnblogs.com/xdyixia/p/9110116.html

select、poll、epoll之间的区别(搜狗面试)
https://www.cnblogs.com/aspirant/p/9166944.html

(1)select==>时间复杂度O(n)-------------------有人说是扫描文件描述符，有人说扫描流，，，到底是撒？？？？流是由文件描述符封装后的，个人觉得还是文件描述符。

它仅仅知道了，有I/O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。
所以select具有O(n)的无差别轮询复杂度，同时处理的流越多，无差别轮询时间就越长。

(2)poll==>时间复杂度O(n)

poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， 但是它没有最大连接数的限制，原因是它是基于链表来存储的.

(3)epoll==>时间复杂度O(1)

epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。所以我们说epoll实际上是事件驱动（每个事件关联上fd）的，此时我们对这些流的操作都是有意义的。（复杂度降低到了O(1)）

IO模型及select、poll、epoll和kqueue的区别
https://www.cnblogs.com/linganxiong/p/5583415.html

(4)KQueue---------------------------------??

(5)IOCP-----------------------------------??


系统间通讯方式之（Java NIO多路复用模式）（四）
https://blog.csdn.net/u010963948/article/details/78507255
IO模型		相对性能		关键思路					操作系统				JAVA支持情况
select		较高			Reactor	windows/Linux		windows/Linux			支持,Reactor模式(反应器设计模式)。Linux操作系统的 kernels 2.4内核版本之前，默认使用select；而目前windows下对同步IO的支持，都是select模型
poll		较高			Reactor	Linux	            Linux        			Linux下的JAVA NIO框架，Linux kernels 2.6内核版本之前使用poll进行支持。也是使用的Reactor模式
epoll		高				Reactor/Proactor			Linux					Linux kernels 2.6内核版本及以后使用epoll进行支持；Linux kernels 2.6内核版本之前使用poll进行支持；另外一定注意，由于Linux下没有Windows下的IOCP技术提供真正的 异步IO 支持，所以Linux下使用epoll模拟异步IO
kqueue		高				Proactor					Linux					目前JAVA的版本不支持


--------------------------------------------------------分割线-------------------------------------------------------------------------------	
Linux五种IO模型
https://www.cnblogs.com/renxs/p/3683189.html

网络编程四种调用方式：同步(Sync)/异步(Async)，阻塞(Block)/非阻塞(Unblock)。


同步：
    所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。也就是必须一件一件事做,等前一件做完了才能做下一件事。

	例如普通B/S模式（同步）：提交请求->等待服务器处理->处理完毕返回 这个期间客户端浏览器不能干任何事

异步：
    异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。

    例如 ajax请求（异步）: 请求通过事件触发->服务器处理（这是浏览器仍然可以作其他事情）->处理完毕

阻塞
    阻塞调用是指调用结果返回之前，当前线程会被挂起（线程进入非可执行状态，在这个状态下，cpu不会给线程分配时间片，即线程暂停运行）。函数只有在得到结果之后才会返回。
 
  同步与阻塞区别：对于同步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回而已。 例如，我们在socket中调用recv函数，如果缓冲区中没有数据，这个函数就会一直等待，直到有数据才返回。而此时，当前线程还会继续处理各种各样的消息。

非阻塞
      非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。

  对象的阻塞模式和阻塞函数调用
	对象是否处于阻塞模式和函数是不是阻塞调用有很强的相关性，但是并不是一一对应的。阻塞对象上可以有非阻塞的调用方式，我们可以通过一定的API去轮询状态，在适当的时候调用阻塞函数，就可以避免阻塞。而对于非阻塞对象，
	调用特殊的函数也可以进入阻塞调用。函数select就是这样的一个例子。

 

1. 同步，就是我调用一个功能，该功能没有结束前，我死等结果。
2. 异步，就是我调用一个功能，不需要知道该功能结果，该功能有结果后通知我（回调通知）
3. 阻塞，就是调用我（函数），我（函数）没有接收完数据或者没有得到结果之前，我不会返回。
4. 非阻塞，就是调用我（函数），我（函数）立即返回，通过select通知调用者


同步IO和异步IO的区别就在于：数据拷贝的时候进程是否阻塞！
阻塞IO和非阻塞IO的区别就在于：应用程序的调用是否立即返回！

