web.xml中的加载顺序：context-param -> listener -> filter -> servlet


================================================contextInitialized:107, ContextLoaderListener================================================初始化context
	@Override
	public void contextInitialized(ServletContextEvent event) {
		initWebApplicationContext(event.getServletContext());
	}

================================================initWebApplicationContext:325, ContextLoader================================================初始化context
	public WebApplicationContext initWebApplicationContext(ServletContext servletContext) {
		===============判断是否已经启动过了
		if (servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) != null) {
			throw new IllegalStateException(
					"Cannot initialize context because there is already a root application context present - " +
					"check whether you have multiple ContextLoader* definitions in your web.xml!");
		}

		Log logger = LogFactory.getLog(ContextLoader.class);
		servletContext.log("Initializing Spring root WebApplicationContext");
		if (logger.isInfoEnabled()) {
			logger.info("Root WebApplicationContext: initialization started");
		}
		long startTime = System.currentTimeMillis();

		try {
			// Store context in local instance variable, to guarantee that
			// it is available on ServletContext shutdown.
			if (this.context == null) {
				this.context = createWebApplicationContext(servletContext);=========================================创建WebApplicationContext
			}
			if (this.context instanceof ConfigurableWebApplicationContext) {
				ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) this.context;
				if (!cwac.isActive()) {
					// The context has not yet been refreshed -> provide services such as
					// setting the parent context, setting the application context id, etc
					if (cwac.getParent() == null) {
						// The context instance was injected without an explicit parent ->
						// determine parent for root web application context, if any.
						ApplicationContext parent = loadParentContext(servletContext);
						cwac.setParent(parent);
					}
					//加载上下文配置，会完成bean解析，加载，注入的过程
					configureAndRefreshWebApplicationContext(cwac, servletContext);
				}
			}
			servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context);

			ClassLoader ccl = Thread.currentThread().getContextClassLoader();
			if (ccl == ContextLoader.class.getClassLoader()) {
				currentContext = this.context;
			}
			else if (ccl != null) {
				currentContextPerThread.put(ccl, this.context);
			}

			if (logger.isDebugEnabled()) {
				logger.debug("Published root WebApplicationContext as ServletContext attribute with name [" +
						WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE + "]");
			}
			if (logger.isInfoEnabled()) {
				long elapsedTime = System.currentTimeMillis() - startTime;
				logger.info("Root WebApplicationContext: initialization completed in " + elapsedTime + " ms");
			}

			return this.context;
		}
		catch (RuntimeException ex) {
			logger.error("Context initialization failed", ex);
			servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, ex);
			throw ex;
		}
		catch (Error err) {
			logger.error("Context initialization failed", err);
			servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, err);
			throw err;
		}
	}
	
	================================================分割线================================================分割线================================================分割线
	protected WebApplicationContext createWebApplicationContext(ServletContext sc) {
		Class<?> contextClass = determineContextClass(sc);============================返回了ConfigurableWebApplicationContext的Class类，这个方法有很多层，看到最后是调用了ContextLoader.properties配置文件，这个配置文件在Spring的包中是和ContextLoader.class文件放在一起的，没有开放给用户使用，不可配置
		if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) {
			throw new ApplicationContextException("Custom context class [" + contextClass.getName() +
					"] is not of type [" + ConfigurableWebApplicationContext.class.getName() + "]");
		}
		return (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);=========实例化org.springframework.web.context.support.XmlWebApplicationContext
	}
	
	
================================================configureAndRefreshWebApplicationContext:443, ContextLoader	================================================加载上下文配置，会完成bean解析，加载，注入的过程
	protected void configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac, ServletContext sc) {
		if (ObjectUtils.identityToString(wac).equals(wac.getId())) {
			// The application context id is still set to its original default value
			// -> assign a more useful id based on available information
			String idParam = sc.getInitParameter(CONTEXT_ID_PARAM);
			if (idParam != null) {
				wac.setId(idParam);
			}
			else {
				// Generate default id...
				wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX +
						ObjectUtils.getDisplayString(sc.getContextPath()));
			}
		}

		wac.setServletContext(sc);
		=====================================读取contextConfigLocation中的xml配置目录，设置WebApplicationContext配置文件setConfigLocation
		=====================================classpath:spring-datasource.xml,classpath:spring.xml,classpath:spring-mvc.xml,classpath:spring-mybatis.xml,classpath:spring-security.xml,
		String configLocationParam = sc.getInitParameter(CONFIG_LOCATION_PARAM);
		if (configLocationParam != null) {
			wac.setConfigLocation(configLocationParam);
		}

		// The wac environment's #initPropertySources will be called in any case when the context
		// is refreshed; do it eagerly here to ensure servlet property sources are in place for
		// use in any post-processing or initialization that occurs below prior to #refresh
		ConfigurableEnvironment env = wac.getEnvironment();
		if (env instanceof ConfigurableWebEnvironment) {
			((ConfigurableWebEnvironment) env).initPropertySources(sc, null);
		}

		customizeContext(sc, wac);
		wac.refresh();
	}
	
	
	
================================================configureAndRefreshWebApplicationContext:414, ContextLoader==================================调用的是之前初始化的XmlWebApplicationContext的refresh()方法
初始化了一个BeanFactory，这个方法进行了一系列对BeanFactory的初始化和装配工作，每个子方法里都进行了大量的操作，直到finishBeanFactoryInitialization()方法，初始化了所有非懒加载的单例bean的实例。


org.springframework.web.context.support.XmlWebApplicationContext
继承
org.springframework.web.context.support.AbstractRefreshableWebApplicationContext
继承
org.springframework.context.support.AbstractRefreshableConfigApplicationContext
继承
org.springframework.context.support.AbstractRefreshableApplicationContext
继承
org.springframework.context.support.AbstractApplicationContext

	

	@Override
	public void refresh() throws BeansException, IllegalStateException {
		synchronized (this.startupShutdownMonitor) {
			// Prepare this context for refreshing.
			========================
			①、这个方法设置context的启动日期。
		　　②、设置context当前的状态，是活动状态还是关闭状态。
		　　③、初始化context environment（上下文环境）中的占位符属性来源。
		　　④、验证所有必需的属性。
			prepareRefresh();

			// Tell the subclass to refresh the internal bean factory.
			========================让这个类（AbstractApplicationContext）的子类刷新内部bean工厂。实际上就是重新创建一个bean工厂。
			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

			// Prepare the bean factory for use in this context.
			========================上一步已经把工厂建好了，但是还不能投入使用，因为工厂里什么都没有，还需要配置一些东西
			prepareBeanFactory(beanFactory);

			try {
				// Allows post-processing of the bean factory in context subclasses.
				上面对bean工厂进行了许多配置，现在需要对bean工厂进行一些处理。
			　　①、添加一个ServletContextAwareProcessor到bean工厂中。
			　　②、在bean工厂自动装配的时候忽略一些接口。如：ServletContextAware、ServletConfigAware
			　　③、注册WEB应用特定的域（scope）到bean工厂中，以便WebApplicationContext可以使用它们。比如"request", "session", "globalSession", "application"，
			　　④、注册WEB应用特定的Environment bean到bean工厂中，以便WebApplicationContext可以使用它们。如："contextParameters", "contextAttributes"
				postProcessBeanFactory(beanFactory);

				// Invoke factory processors registered as beans in the context.
				这一步也是对bean工厂进行一些处理。这一步主要是调用所有的bean工厂处理器（BeanFactoryPostProcessor）对bean工厂进行一些处理。
				这个方法必须在所有的singleton初始化之前调用。
				invokeBeanFactoryPostProcessors(beanFactory);

				// Register bean processors that intercept bean creation.
				注册用来拦截bean创建的BeanPostProcessor bean.这个方法需要在所有的application bean初始化之前调用。把这个注册的任务委托给了PostProcessorRegistrationDelegate来完成。
				//同时解析
				registerBeanPostProcessors(beanFactory);

				// Initialize message source for this context.
				初始化MessageSource接口的一个实现类。这个接口提供了消息处理功能。主要用于国际化/i18n。
				initMessageSource();

				// Initialize event multicaster for this context.
				为这个context初始化一个事件广播器（ApplicationEventMulticaster）。
				这个常量就是的ApplicationEventMulticaster bean的名字。程序首先会检查bean工厂中是否有bean的名字和这个常量相同的，如果没有则说明没有那么就使用默认的ApplicationEventMulticaster 的实现：SimpleApplicationEventMulticaster
				initApplicationEventMulticaster();

				// Initialize other special beans in specific context subclasses.
				在AbstractApplicationContext的子类中初始化其他特殊的bean。其实就是初始化ThemeSource接口的实例。这个方法需要在所有单例bean初始化之前调用。
				onRefresh();

				// Check for listener beans and register them.
				注册应用的监听器。就是注册实现了ApplicationListener接口的监听器bean，这些监听器是注册到ApplicationEventMulticaster中的。这不会影响到其它监听器bean。在注册完以后，还会将其前期的事件发布给相匹配的监听器。
				registerListeners();

				// Instantiate all remaining (non-lazy-init) singletons.
				完成bean工厂的初始化工作。这一步非常复杂，也非常重要，涉及到了bean的创建。
				第二步中只是完成了BeanDefinition的定义、解析、处理、注册。但是还没有初始化bean实例。这一步将初始化所有非懒加载的单例bean。这一步将会重新在一篇新的笔记中介绍。
				finishBeanFactoryInitialization(beanFactory);

				// Last step: publish corresponding event.
				完成context的刷新。主要是调用LifecycleProcessor的onRefresh()方法，并且发布事件（ContextRefreshedEvent）。
				finishRefresh();
			}

			catch (BeansException ex) {
				if (logger.isWarnEnabled()) {
					logger.warn("Exception encountered during context initialization - " +
							"cancelling refresh attempt: " + ex);
				}

				// Destroy already created singletons to avoid dangling resources.
				destroyBeans();

				// Reset 'active' flag.
				cancelRefresh(ex);

				// Propagate exception to caller.
				throw ex;
			}

			finally {
				// Reset common introspection caches in Spring's core, since we
				// might not ever need metadata for singleton beans anymore...
				resetCommonCaches();
			}
		}
	}
	================================================分割线================================================分割线================================================分割线
	AbstractApplicationContext
	protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {
		PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());

		// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime
		// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)
		if (beanFactory.getTempClassLoader() == null && beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
			beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
			beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
		}
	}
	================================================分割线================================================分割线================================================分割线
	PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors
	
	public static void invokeBeanFactoryPostProcessors(
			ConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors) {

		// Invoke BeanDefinitionRegistryPostProcessors first, if any.
		Set<String> processedBeans = new HashSet<String>();
		
		//先判断beanFactory是不是BeanDefinitionRegistry类型，这里的beanFactory
		//是DefaultListableBeanFactory类型实现了BeanDefinitionRegistry接口
		if (beanFactory instanceof BeanDefinitionRegistry) {
			BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;
			List<BeanFactoryPostProcessor> regularPostProcessors = new LinkedList<BeanFactoryPostProcessor>();
			List<BeanDefinitionRegistryPostProcessor> registryPostProcessors =
					new LinkedList<BeanDefinitionRegistryPostProcessor>();

			for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) {
				if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) {
					BeanDefinitionRegistryPostProcessor registryPostProcessor =
							(BeanDefinitionRegistryPostProcessor) postProcessor;
					registryPostProcessor.postProcessBeanDefinitionRegistry(registry);
					registryPostProcessors.add(registryPostProcessor);
				}
				else {
					regularPostProcessors.add(postProcessor);
				}
			}

			// Do not initialize FactoryBeans here: We need to leave all regular beans
			// uninitialized to let the bean factory post-processors apply to them!
			// Separate between BeanDefinitionRegistryPostProcessors that implement
			// PriorityOrdered, Ordered, and the rest.
			============在spring容器中得到BeanDefinitionRegistryPostProcessor类型的postProcessorName
			String[] postProcessorNames =
					beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);

			// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.
			List<BeanDefinitionRegistryPostProcessor> priorityOrderedPostProcessors = new ArrayList<BeanDefinitionRegistryPostProcessor>();
			for (String ppName : postProcessorNames) {
				============如果确实实现了PriorityOrdered接口
				if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
					priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
					processedBeans.add(ppName);
				}
			}
			sortPostProcessors(beanFactory, priorityOrderedPostProcessors);
			registryPostProcessors.addAll(priorityOrderedPostProcessors);
			invokeBeanDefinitionRegistryPostProcessors(priorityOrderedPostProcessors, registry);

			// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.
			postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
			List<BeanDefinitionRegistryPostProcessor> orderedPostProcessors = new ArrayList<BeanDefinitionRegistryPostProcessor>();
			for (String ppName : postProcessorNames) {
				if (!processedBeans.contains(ppName) && beanFactory.isTypeMatch(ppName, Ordered.class)) {
					orderedPostProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
					processedBeans.add(ppName);
				}
			}
			sortPostProcessors(beanFactory, orderedPostProcessors);
			============registryPostProcessors中存储所有的priorityOrderedPostProcessors
			registryPostProcessors.addAll(orderedPostProcessors);
			invokeBeanDefinitionRegistryPostProcessors(orderedPostProcessors, registry);

			// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.
			boolean reiterate = true;
			while (reiterate) {
				reiterate = false;
				postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
				for (String ppName : postProcessorNames) {
					if (!processedBeans.contains(ppName)) {
						BeanDefinitionRegistryPostProcessor pp = beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class);
						registryPostProcessors.add(pp);
						processedBeans.add(ppName);
						pp.postProcessBeanDefinitionRegistry(registry);
						reiterate = true;
					}
				}
			}

			// Now, invoke the postProcessBeanFactory callback of all processors handled so far.
			invokeBeanFactoryPostProcessors(registryPostProcessors, beanFactory);
			invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);
		}

		else {
			// Invoke factory processors registered with the context instance.
			invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);
		}

		// Do not initialize FactoryBeans here: We need to leave all regular beans
		// uninitialized to let the bean factory post-processors apply to them!
		String[] postProcessorNames =
				beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);

		// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,
		// Ordered, and the rest.
		List<BeanFactoryPostProcessor> priorityOrderedPostProcessors = new ArrayList<BeanFactoryPostProcessor>();
		List<String> orderedPostProcessorNames = new ArrayList<String>();
		List<String> nonOrderedPostProcessorNames = new ArrayList<String>();
		for (String ppName : postProcessorNames) {
			if (processedBeans.contains(ppName)) {
				// skip - already processed in first phase above
			}
			else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
				priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));
			}
			else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {
				orderedPostProcessorNames.add(ppName);
			}
			else {
				nonOrderedPostProcessorNames.add(ppName);
			}
		}

		// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.
		sortPostProcessors(beanFactory, priorityOrderedPostProcessors);
		invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);

		// Next, invoke the BeanFactoryPostProcessors that implement Ordered.
		List<BeanFactoryPostProcessor> orderedPostProcessors = new ArrayList<BeanFactoryPostProcessor>();
		for (String postProcessorName : orderedPostProcessorNames) {
			orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
		}
		sortPostProcessors(beanFactory, orderedPostProcessors);
		invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);

		// Finally, invoke all other BeanFactoryPostProcessors.
		List<BeanFactoryPostProcessor> nonOrderedPostProcessors = new ArrayList<BeanFactoryPostProcessor>();
		for (String postProcessorName : nonOrderedPostProcessorNames) {
			nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
		}
		invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);

		// Clear cached merged bean definitions since the post-processors might have
		// modified the original metadata, e.g. replacing placeholders in values...
		beanFactory.clearMetadataCache();
	}
	
	================================================分割线================================================分割线================================================分割线
	protected void prepareRefresh() {
		this.startupDate = System.currentTimeMillis();
		this.closed.set(false);
		this.active.set(true);

		if (logger.isInfoEnabled()) {
			logger.info("Refreshing " + this);
		}

		// Initialize any placeholder property sources in the context environment
		initPropertySources();

		// Validate that all properties marked as required are resolvable
		// see ConfigurablePropertyResolver#setRequiredProperties
		getEnvironment().validateRequiredProperties();

		// Allow for the collection of early ApplicationEvents,
		// to be published once the multicaster is available...
		this.earlyApplicationEvents = new LinkedHashSet<ApplicationEvent>();
	}
	
	================================================分割线================================================分割线================================================分割线
	/**
	 * Tell the subclass to refresh the internal bean factory.
	 * @return the fresh BeanFactory instance
	 * @see #refreshBeanFactory()
	 * @see #getBeanFactory()
	 */
	protected ConfigurableListableBeanFactory obtainFreshBeanFactory() {
		refreshBeanFactory();======================================================真正的刷新bean工厂。
		ConfigurableListableBeanFactory beanFactory = getBeanFactory();
		if (logger.isDebugEnabled()) {
			logger.debug("Bean factory for " + getDisplayName() + ": " + beanFactory);
		}
		return beanFactory;
	}
	================================================分割线================================================分割线================================================分割线
	refreshBeanFactory:127, AbstractRefreshableApplicationContext======================================================
		@Override
		protected final void refreshBeanFactory() throws BeansException {
			if (hasBeanFactory()) {========================如果已经存在一个bean工厂那么就将其销毁，关闭。
				destroyBeans();
				closeBeanFactory();
			}
			try {
				DefaultListableBeanFactory beanFactory = createBeanFactory();=======================新建一个Bean工厂。
				beanFactory.setSerializationId(getId());
				customizeBeanFactory(beanFactory);=================================================自定义bean工厂。
				======================================================加载BeanDefinition
				==========================
				loadBeanDefinitions(beanFactory);
				synchronized (this.beanFactoryMonitor) {
					this.beanFactory = beanFactory;======================================================将创建好的bean工厂的引用交给的context来管理
				}
			}
			catch (IOException ex) {================================================================加载bean定义资源的时候可能会抛出异常
				throw new ApplicationContextException("I/O error parsing bean definition source for " + getDisplayName(), ex);
			}
		}
		
		
	================================================分割线================================================分割线================================================分割线	
	protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {
		// Tell the internal bean factory to use the context's class loader etc.
		============================设置类加载器：存在则直接设置/不存在则新建一个默认类加载器
		beanFactory.setBeanClassLoader(getClassLoader());
		============================设置EL表达式解析器（Bean初始化完成后填充属性时会用到）
		beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));
		============================设置属性注册解析器PropertyEditor
		beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));

		// Configure the bean factory with context callbacks.
		============================将当前的ApplicationContext对象交给ApplicationContextAwareProcessor类来处理，从而在	Aware接口实现类中的注入applicationContext
		beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));
		============================设置忽略自动装配的接口
		beanFactory.ignoreDependencyInterface(EnvironmentAware.class);
		beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);
		beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);
		beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);
		beanFactory.ignoreDependencyInterface(MessageSourceAware.class);
		beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);

		// BeanFactory interface not registered as resolvable type in a plain factory.
		============================注册可以解析的自动装配
		// MessageSource registered (and found for autowiring) as a bean.
		beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);
		beanFactory.registerResolvableDependency(ResourceLoader.class, this);
		beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);
		beanFactory.registerResolvableDependency(ApplicationContext.class, this);

		// Register early post-processor for detecting inner beans as ApplicationListeners.
		beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));

		// Detect a LoadTimeWeaver and prepare for weaving, if found.
		============================如果当前BeanFactory包含loadTimeWeaver Bean，说明存在类加载期织入AspectJ，则把当前BeanFactory交给类加载期BeanPostProcessor实现类LoadTimeWeaverAwareProcessor来处理，从而实现类加载期织入AspectJ的目的。
		if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
			beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
			// Set a temporary ClassLoader for type matching.
			beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
		}

		// Register default environment beans.
		============================注册当前容器环境environment组件Bean
		if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {
			beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());
		}
		============================注册系统配置systemProperties组件Bean
		if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {
			beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());
		}
		============================注册系统环境systemEnvironment组件Bean
		if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {
			beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());
		}
		
		1.设置类加载器；
	    2.设置EL表达式解析器（Bean创建完成填充属性时使用）和属性注册解析器
	    3.利用BeanPostProcessor的特性给各种Aware接口的实现类注入ApplicationContext中对应的属性
	    4.设置各种Aware接口的实现类为忽略自动装配
	    5.设置自动装配的类（BeanFactory，ResourceLoader，ApplicationEventPublisher，ApplicationContext）
	    6.如果BeanFactory中存在loadTimeWeaver的bean，那么需要添加动态织入功能
	    7.注册各种可用组件（environment，systemProperties，systemEnvironment）
	}	
	
	
	================================================分割线================================================分割线================================================分割线
	@Override
	protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {
		beanFactory.addBeanPostProcessor(new ServletContextAwareProcessor(this.servletContext, this.servletConfig));
		beanFactory.ignoreDependencyInterface(ServletContextAware.class);
		beanFactory.ignoreDependencyInterface(ServletConfigAware.class);

		WebApplicationContextUtils.registerWebApplicationScopes(beanFactory, this.servletContext);
		WebApplicationContextUtils.registerEnvironmentBeans(beanFactory, this.servletContext, this.servletConfig);
	}
	
	================================================分割线================================================分割线================================================分割线
	protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {
		PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());

		// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime
		// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)
		if (beanFactory.getTempClassLoader() == null && beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
			beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
			beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
		}
	}
	================================================分割线================================================分割线================================================分割线
finishBeanFactoryInitialization:835, AbstractApplicationContext===============================================================了解了Spring初始化过程中两种后置器postProcess的实现原理和调用过程，也明白了BeanDefinition的解析和创建，这次我们继续来分析Spring容器核心创建方法refresh（）的最后一步finishBeanFactoryInitialization(beanFactory)
	protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {
		// Initialize conversion service for this context.
		if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &&
				beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) {
			beanFactory.setConversionService(
					beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));
		}

		// Register a default embedded value resolver if no bean post-processor
		// (such as a PropertyPlaceholderConfigurer bean) registered any before:
		// at this point, primarily for resolution in annotation attribute values.
		if (!beanFactory.hasEmbeddedValueResolver()) {
			beanFactory.addEmbeddedValueResolver(new StringValueResolver() {
				@Override
				public String resolveStringValue(String strVal) {
					return getEnvironment().resolvePlaceholders(strVal);
				}
			});
		}

		// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.
		String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);
		for (String weaverAwareName : weaverAwareNames) {
			getBean(weaverAwareName);
		}

		// Stop using the temporary ClassLoader for type matching.
		beanFactory.setTempClassLoader(null);

		// Allow for caching all bean definition metadata, not expecting further changes.
		beanFactory.freezeConfiguration();

		// Instantiate all remaining (non-lazy-init) singletons.
		beanFactory.preInstantiateSingletons();
	}
	================================================分割线================================================分割线================================================分割线
	preInstantiateSingletons:729, DefaultListableBeanFactory===============================================================
	
		@Override
		public void preInstantiateSingletons() throws BeansException {
			if (this.logger.isDebugEnabled()) {
				this.logger.debug("Pre-instantiating singletons in " + this);
			}

			// Iterate over a copy to allow for init methods which in turn register new bean definitions.
			// While this may not be part of the regular factory bootstrap, it does otherwise work fine.
			List<String> beanNames = new ArrayList<String>(this.beanDefinitionNames);

			// Trigger initialization of all non-lazy singleton beans...
			for (String beanName : beanNames) {
				这部分是通过getSingleton(beanName)方法去singleton缓存中找bean实例，应该是拿不到的，因为我们是第一次初始化，缓存中肯定不存在。
				RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);=====================================第一段
				if (!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()) {
					if (isFactoryBean(beanName)) {
						final FactoryBean<?> factory = (FactoryBean<?>) getBean(FACTORY_BEAN_PREFIX + beanName);
						boolean isEagerInit;
						if (System.getSecurityManager() != null && factory instanceof SmartFactoryBean) {
							isEagerInit = AccessController.doPrivileged(new PrivilegedAction<Boolean>() {
								@Override
								public Boolean run() {
									return ((SmartFactoryBean<?>) factory).isEagerInit();
								}
							}, getAccessControlContext());
						}
						else {
							isEagerInit = (factory instanceof SmartFactoryBean &&
									((SmartFactoryBean<?>) factory).isEagerInit());
						}
						if (isEagerInit) {
							getBean(beanName);
						}
					}
					else {
						这段是根据当前的beanfactory获取父一级的beanfactory，然后逐级递归的查找我们需要的bean，很显然在这里依然获取不到我们的bean，原因同第一部分。
						getBean(beanName);=====================================第一段
					}
				}
			}

			// Trigger post-initialization callback for all applicable beans...
			for (String beanName : beanNames) {
				Object singletonInstance = getSingleton(beanName);
				if (singletonInstance instanceof SmartInitializingSingleton) {
					final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;
					if (System.getSecurityManager() != null) {
						AccessController.doPrivileged(new PrivilegedAction<Object>() {
							@Override
							public Object run() {
								smartSingleton.afterSingletonsInstantiated();
								return null;
							}
						}, getAccessControlContext());
					}
					else {
						smartSingleton.afterSingletonsInstantiated();
					}
				}
			}
		}
	================================================分割线================================================分割线================================================分割线
	
		第一段:getMergedLocalBeanDefinition=======>getMergedBeanDefinition(beanName, getBeanDefinition(beanName))
		=======>getMergedBeanDefinition(beanName, bd, null)===这部分是通过getSingleton(beanName)方法去singleton缓存中找bean实例，应该是拿不到的，因为我们是第一次初始化，缓存中肯定不存在。
		protected RootBeanDefinition getMergedBeanDefinition(
				String beanName, BeanDefinition bd, BeanDefinition containingBd)
				throws BeanDefinitionStoreException {

			synchronized (this.mergedBeanDefinitions) {
				RootBeanDefinition mbd = null;

				// Check with full lock now in order to enforce the same merged instance.
				if (containingBd == null) {
					mbd = this.mergedBeanDefinitions.get(beanName);
				}

				if (mbd == null) {
					if (bd.getParentName() == null) {
						// Use copy of given root bean definition.
						if (bd instanceof RootBeanDefinition) {
							mbd = ((RootBeanDefinition) bd).cloneBeanDefinition();
						}
						else {
							mbd = new RootBeanDefinition(bd);
						}
					}
					else {
						// Child bean definition: needs to be merged with parent.
						BeanDefinition pbd;
						try {
							String parentBeanName = transformedBeanName(bd.getParentName());
							if (!beanName.equals(parentBeanName)) {
								pbd = getMergedBeanDefinition(parentBeanName);
							}
							else {
								BeanFactory parent = getParentBeanFactory();
								if (parent instanceof ConfigurableBeanFactory) {
									pbd = ((ConfigurableBeanFactory) parent).getMergedBeanDefinition(parentBeanName);
								}
								else {
									throw new NoSuchBeanDefinitionException(parentBeanName,
											"Parent name '" + parentBeanName + "' is equal to bean name '" + beanName +
											"': cannot be resolved without an AbstractBeanFactory parent");
								}
							}
						}
						catch (NoSuchBeanDefinitionException ex) {
							throw new BeanDefinitionStoreException(bd.getResourceDescription(), beanName,
									"Could not resolve parent bean definition '" + bd.getParentName() + "'", ex);
						}
						// Deep copy with overridden values.
						mbd = new RootBeanDefinition(pbd);
						mbd.overrideFrom(bd);
					}

					// Set default singleton scope, if not configured before.
					if (!StringUtils.hasLength(mbd.getScope())) {
						mbd.setScope(RootBeanDefinition.SCOPE_SINGLETON);
					}

					// A bean contained in a non-singleton bean cannot be a singleton itself.
					// Let's correct this on the fly here, since this might be the result of
					// parent-child merging for the outer bean, in which case the original inner bean
					// definition will not have inherited the merged outer bean's singleton status.
					if (containingBd != null && !containingBd.isSingleton() && mbd.isSingleton()) {
						mbd.setScope(containingBd.getScope());
					}

					// Only cache the merged bean definition if we're already about to create an
					// instance of the bean, or at least have already created an instance before.
					if (containingBd == null && isCacheBeanMetadata()) {
						this.mergedBeanDefinitions.put(beanName, mbd);
					}
				}

				return mbd;
			}
		}
		
		================================================分割线================================================分割线================================================分割线
		第二段：
		doGetBean:260, AbstractBeanFactory (org.springframework.beans.factory.support)==================>getBean:197, AbstractBeanFactory (org.springframework.beans.factory.support)
		==================>preInstantiateSingletons:761, DefaultListableBeanFactory (org.springframework.beans.factory.support)
		==================>这段是根据当前的beanfactory获取父一级的beanfactory，然后逐级递归的查找我们需要的bean，很显然在这里依然获取不到我们的bean，原因同第一部分。
		protected <T> T doGetBean(
			final String name, final Class<T> requiredType, final Object[] args, boolean typeCheckOnly)
			throws BeansException {

		final String beanName = transformedBeanName(name);
		Object bean;

		// Eagerly check singleton cache for manually registered singletons.
		Object sharedInstance = getSingleton(beanName);
		if (sharedInstance != null && args == null) {
			if (logger.isDebugEnabled()) {
				if (isSingletonCurrentlyInCreation(beanName)) {
					logger.debug("Returning eagerly cached instance of singleton bean '" + beanName +
							"' that is not fully initialized yet - a consequence of a circular reference");
				}
				else {
					logger.debug("Returning cached instance of singleton bean '" + beanName + "'");
				}
			}
			bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);
		}

		else {
			// Fail if we're already creating this bean instance:
			// We're assumably within a circular reference.
			if (isPrototypeCurrentlyInCreation(beanName)) {
				throw new BeanCurrentlyInCreationException(beanName);
			}

			// Check if bean definition exists in this factory.
			BeanFactory parentBeanFactory = getParentBeanFactory();
			if (parentBeanFactory != null && !containsBeanDefinition(beanName)) {
				// Not found -> check parent.
				String nameToLookup = originalBeanName(name);
				if (args != null) {
					// Delegation to parent with explicit args.
					return (T) parentBeanFactory.getBean(nameToLookup, args);
				}
				else {
					// No args -> delegate to standard getBean method.
					return parentBeanFactory.getBean(nameToLookup, requiredType);
				}
			}
================================================分割线================================================分割线================================================分割线
			第三部分先判断并把需要创建的bean打上正在创建标记，也就是开头的if判断加markBeanAsCreated(beanName)方法（这样做的目的是在我创建这个bean之前就先打上创建标记，告诉其它来创建的线程，避免了重复创建，
			那么这个方法内部肯定是同步的），然后获取到该bean对应的BeanDefinition，在Spring创建初期把bean的初始化信息通过配置文件（xml）和反射等预先存在了BeanDefinition中，当然也包括bean依赖等，
			所以在这里把BeanDefinition里存储的依赖bean挨个取出来进行实例化
			if (!typeCheckOnly) {=====================================================================第三段
				markBeanAsCreated(beanName);
			}

			try {
				final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
				checkMergedBeanDefinition(mbd, beanName, args);

				// Guarantee initialization of beans that the current bean depends on.
				String[] dependsOn = mbd.getDependsOn();
				if (dependsOn != null) {
					for (String dep : dependsOn) {
						if (isDependent(beanName, dep)) {
							throw new BeanCreationException(mbd.getResourceDescription(), beanName,
									"Circular depends-on relationship between '" + beanName + "' and '" + dep + "'");
						}
						registerDependentBean(dep, beanName);
						getBean(dep);
					}
				}

				// Create bean instance.
================================================分割线================================================分割线================================================分割线				
				这部分我们通过单例的代码来进行分析，如果当前bean是Singleton，则调用createBean(beanName, mbd, args)方法，并返回。我们继续看这个方法
				if (mbd.isSingleton()) {====================================第四段
					sharedInstance = getSingleton(beanName, new ObjectFactory<Object>() {
						@Override
						public Object getObject() throws BeansException {
							try {
								return createBean(beanName, mbd, args);
							}
							catch (BeansException ex) {
								// Explicitly remove instance from singleton cache: It might have been put there
								// eagerly by the creation process, to allow for circular reference resolution.
								// Also remove any beans that received a temporary reference to the bean.
								destroySingleton(beanName);
								throw ex;
							}
						}
					});
					bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
				}

				else if (mbd.isPrototype()) {
					// It's a prototype -> create a new instance.
					Object prototypeInstance = null;
					try {
						beforePrototypeCreation(beanName);
						prototypeInstance = createBean(beanName, mbd, args);
					}
					finally {
						afterPrototypeCreation(beanName);
					}
					bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
				}

				else {
					String scopeName = mbd.getScope();
					final Scope scope = this.scopes.get(scopeName);
					if (scope == null) {
						throw new IllegalStateException("No Scope registered for scope name '" + scopeName + "'");
					}
					try {
						Object scopedInstance = scope.get(beanName, new ObjectFactory<Object>() {
							@Override
							public Object getObject() throws BeansException {
								beforePrototypeCreation(beanName);
								try {
									return createBean(beanName, mbd, args);
								}
								finally {
									afterPrototypeCreation(beanName);
								}
							}
						});
						bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
					}
					catch (IllegalStateException ex) {
						throw new BeanCreationException(beanName,
								"Scope '" + scopeName + "' is not active for the current thread; consider " +
								"defining a scoped proxy for this bean if you intend to refer to it from a singleton",
								ex);
					}
				}
			}
			catch (BeansException ex) {
				cleanupAfterBeanCreationFailure(beanName);
				throw ex;
			}
		}
		
================================================分割线================================================分割线================================================分割线		
		createBean:448, AbstractAutowireCapableBeanFactory====================================第五段
		@Override
		protected Object createBean(String beanName, RootBeanDefinition mbd, Object[] args) throws BeanCreationException {
			if (logger.isDebugEnabled()) {
				logger.debug("Creating instance of bean '" + beanName + "'");
			}
			RootBeanDefinition mbdToUse = mbd;

			// Make sure bean class is actually resolved at this point, and
			// clone the bean definition in case of a dynamically resolved Class
			// which cannot be stored in the shared merged bean definition.
			====================================判断该bean的class是否存在，也就是该bean是可以通过class创建的
			Class<?> resolvedClass = resolveBeanClass(mbd, beanName);
			if (resolvedClass != null && !mbd.hasBeanClass() && mbd.getBeanClassName() != null) {
				mbdToUse = new RootBeanDefinition(mbd);
				mbdToUse.setBeanClass(resolvedClass);
			}

			// Prepare method overrides.
			try {
				====================================准备方法重写
				mbdToUse.prepareMethodOverrides();
			}
			catch (BeanDefinitionValidationException ex) {
				throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),
						beanName, "Validation of method overrides failed", ex);
			}

			try {
				// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.
				====================================这边有个return，也就是说这边有可能提前返回bean，看注释：Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.
				我们以前在beanPostProcessor时说过，beanPostProcessor是可以临时修改bean的，它的优先级高于正常实例化bean的（也就是后续实例化该bean的过程），如果beanPostProcessor能返回，则直接返回了
				Object bean = resolveBeforeInstantiation(beanName, mbdToUse);
				if (bean != null) {
					return bean;
				}
			}
			catch (Throwable ex) {
				throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName,
						"BeanPostProcessor before instantiation of bean failed", ex);
			}

			Object beanInstance = doCreateBean(beanName, mbdToUse, args);
			if (logger.isDebugEnabled()) {
				logger.debug("Finished creating instance of bean '" + beanName + "'");
			}
			return beanInstance;
		}
================================================分割线================================================分割线================================================分割线		
		最后doCreateBean