官网API
https://docs.oracle.com/javase/8/docs/api/

经典解释监视器和对象锁
https://blog.csdn.net/fenglibing/article/details/1483930
在JVM的规范中，有这么一些话：   
  “在JVM中，每个对象和类在逻辑上都是和一个监视器相关联的”   
    “为了实现监视器的排他性监视能力，JVM为每一个对象和类都关联一个锁”   
  “锁住了一个对象，就是获得对象相关联的监视器” 
从这些话，看出监视器和对象锁好像是一回事，那为何要定义两个东西，若不一样，他们的关系如何？ 
  
Unsafe-----------------

HotSpot还是包含了一个后门sun.misc.Unsafe，提供了一些可以直接操控内存和线程的底层操作.
Unsafe扩展到的类库以及API
https://blog.csdn.net/majinggogogo/article/details/79736958

---------------------------------------------------------------------------------------Unsafe--------------------------------------------
Java魔法类：sun.misc.Unsafe
https://www.cnblogs.com/suxuan/p/4948608.html
Unsafe API的大部分方法都是native实现，它由105个方法组成，主要包括以下几类：
（1）Info相关。主要返回某些低级别的内存信息：addressSize(), pageSize()
（2）Objects相关。主要提供Object和它的域操纵方法：allocateInstance(),objectFieldOffset()
（3）Class相关。主要提供Class和它的静态域操纵方法：staticFieldOffset(),defineClass(),defineAnonymousClass(),ensureClassInitialized()
（4）Arrays相关。数组操纵方法：arrayBaseOffset(),arrayIndexScale()
（5）Synchronization相关。主要提供低级别同步原语（如基于CPU的CAS（Compare-And-Swap）原语）：monitorEnter(),tryMonitorEnter(),monitorExit(),compareAndSwapInt(),putOrderedInt()
（6）Memory相关。直接内存访问方法（绕过JVM堆直接操纵本地内存）：allocateMemory(),copyMemory(),freeMemory(),getAddress(),getInt(),putInt()

//扩充内存  
public native long reallocateMemory(long address, long bytes);    
//分配内存  
public native long allocateMemory(long bytes);    
//释放内存  
public native void freeMemory(long address);    
//在给定的内存块中设置值  
public native void setMemory(Object o, long offset, long bytes, byte value);    
//从一个内存块拷贝到另一个内存块  
public native void copyMemory(Object srcBase, long srcOffset, Object destBase, long destOffset, long bytes);    
//获取值，不管java的访问限制，其他有类似的getInt，getDouble，getLong，getChar等等  
public native Object getObject(Object o, long offset);    
//设置值，不管java的访问限制，其他有类似的putInt,putDouble，putLong，putChar等等  
public native void putObject(Object o, long offset);    
//从一个给定的内存地址获取本地指针，如果不是allocateMemory方法的，结果将不确定  
public native long getAddress(long address);    
//存储一个本地指针到一个给定的内存地址,如果地址不是allocateMemory方法的，结果将不确定  
public native void putAddress(long address, long x);    
//该方法返回给定field的内存地址偏移量，这个值对于给定的filed是唯一的且是固定不变的  
public native long staticFieldOffset(Field f);    
//报告一个给定的字段的位置，不管这个字段是private，public还是保护类型，和staticFieldBase结合使用  
public native long objectFieldOffset(Field f);  
//获取一个给定字段的位置  
public native Object staticFieldBase(Field f);    
//确保给定class被初始化，这往往需要结合基类的静态域（field）  
public native void ensureClassInitialized(Class c);   
//可以获取数组第一个元素的偏移地址  
public native int arrayBaseOffset(Class arrayClass);   
//可以获取数组的转换因子，也就是数组中元素的增量地址。将arrayBaseOffset与arrayIndexScale配合使用， 可以定位数组中每个元素在内存中的位置  
public native int arrayIndexScale(Class arrayClass);  
//获取本机内存的页数，这个值永远都是2的幂次方  
public native int pageSize();    
//告诉虚拟机定义了一个没有安全检查的类，默认情况下这个类加载器和保护域来着调用者类  
public native Class defineClass(String name, byte[] b, int off, int len, ClassLoader loader, ProtectionDomain protectionDomain);  
//定义一个类，但是不让它知道类加载器和系统字典  
public native Class defineAnonymousClass(Class hostClass, byte[] data, Object[] cpPatches);  
//锁定对象，必须是没有被锁的
public native void monitorEnter(Object o);  
//解锁对象  
public native void monitorExit(Object o);   
//试图锁定对象，返回true或false是否锁定成功，如果锁定，必须用monitorExit解锁  
public native boolean tryMonitorEnter(Object o);  
//引发异常，没有通知  
public native void throwException(Throwable ee);    
//CAS，如果对象偏移量上的值=期待值，更新为x,返回true.否则false.类似的有compareAndSwapInt,compareAndSwapLong,compareAndSwapBoolean,compareAndSwapChar等等。  
public final native boolean compareAndSwapObject(Object o, long offset,  Object expected, Object x);  
// 该方法获取对象中offset偏移地址对应的整型field的值,支持volatile load语义。类似的方法有getIntVolatile，getBooleanVolatile等等  
public native Object getObjectVolatile(Object o, long offset);  
//线程调用该方法，线程将一直阻塞直到超时，或者是中断条件出现。  
public native void park(boolean isAbsolute, long time);  
//终止挂起的线程，恢复正常.java.util.concurrent包中挂起操作都是在LockSupport类实现的，也正是使用这两个方法
public native void unpark(Object thread);  
//获取系统在不同时间系统的负载情况  
public native int getLoadAverage(double[] loadavg, int nelems);  
//创建一个类的实例，不需要调用它的构造函数、初使化代码、各种JVM安全检查以及其它的一些底层的东西。即使构造函数是私有，我们也可以通过这个方法创建它的实例,对于单例模式，简直是噩梦，哈哈  
public native Object allocateInstance(Class cls) throws InstantiationException;  

---------------------------------------------------------------------------------------LockSupport--------------------------------------------
LockSupport -------->由Unsafe.park/unpark衍生类,可以用来实现线程的阻塞/唤醒,相比sleep和await没有锁的概念
https://my.oschina.net/oxf1992/blog/837351

java.util.concurrent.locks包分析：
JUC大集合分析---------------精选
https://my.oschina.net/oxf1992?tab=newest&catalogId=5603328

Java多线程系列--“JUC锁”01之 框架---------------精选
http://www.cnblogs.com/skywang12345/p/3496098.html

--------------------------------------------------------------------------------------AbstractQueuedSynchronizer-----------------------------------------
JUC - 原型图--------锁分为：公平锁和非公平锁
https://my.oschina.net/oxf1992/blog/836880
AQS，即 AbstractQueuedSynchronizer 类。该类可以说是整个 JUC 包的核心。
因为在 JUC 中所有的锁都定义了一个内部类 ——Sync（同步器），同步器负责锁的同步策略，通常有公平策略/非公平策略之分，采用不同策略的锁也被区分为公平锁/非公平锁。
而 Sync 正是继承自 AQS 类。

JUC系列 - AQS CLH同步队列------------>解剖AQS中CLH队列------------>类似于车库有两车位，每次保安只会让两辆车进来，其他的车都等着，有位子了就放进来一辆。---->CLH锁也是一种基于链表的可扩展、高性能、公平的自旋锁，申请线程只在本地变量上自旋，它不断轮询前驱的状态，如果发现前驱释放了锁就结束自旋。
https://www.jianshu.com/p/b26dfd9f9de7
https://www.cnblogs.com/chenssy/p/5087652.html

java并发-独占锁与共享锁
https://blog.csdn.net/wojiushiwo945you/article/details/42292999
AQS的内部类Node定义了两个常量SHARED和EXCLUSIVE，他们分别标识 AQS队列中等待线程的锁获取模式.
java并发包提供的加锁模式分为独占锁和共享锁，独占锁模式下，每次只能有一个线程能持有锁，ReentrantLock就是以独占方式实现的互斥锁。共享锁，则允许多个线程同时获取锁，并发访问 共享资源，如：ReadWriteLock

轻松掌握java读写锁(ReentrantReadWriteLock)的实现原理
https://blog.csdn.net/yanyan19880509/article/details/52435135
--------------------------------------------------------------------------------------LockSupport-----------------------------------------
JUC - LockSupport
https://my.oschina.net/oxf1992/blog/837351
LockSupport提供了park和unpark进行线程的挂起和恢复操作（UNSAFE）
https://blog.csdn.net/opensure/article/details/53349698
LockSupport有以下不同和特点：
		其实现机制和wait/notify有所不同，面向的是线程。
		不需要依赖监视器
		与wait/notify没有交集
		使用起来更加灵活方便
--------------------------------------------------------------------------------------Lock-----------------------------------------
k = k + 1;
k++ 等于（k=k）+ 1
++k 等于（k+1）=k

操作系统中不同的锁--------->信号量（Semaphore）/互斥量 （Mutex）/临界区（Critical Section）/读写锁（Read-Write Lock）/条件变量（Condition Variable）
https://www.cnblogs.com/yuxiang204/archive/2012/10/16/2726813.html

Java中的锁分类------>公平锁/非公平锁
					可重入锁
					独享锁/共享锁
					互斥锁/读写锁
					乐观锁/悲观锁
					分段锁-->分段锁其实是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。
					偏向锁/轻量级锁/重量级锁
					自旋锁
https://www.cnblogs.com/qifengshi/p/6831055.html


同步中的四种锁synchronized、ReentrantLock、ReentrantReadWriteLock、StampedLock
https://www.cnblogs.com/dennyzhangdd/p/6925473.html#_label3
synchronized是在JVM层面上实现的，可以通过一些监控工具控制synchronized的锁定，当代码出现异常时，JVM会自动释放锁定。当只有少量竞争者的时候，synchronized是一个很好的通用的锁实现。synchronized的锁是针对一个对象的。
ReentrantLock、ReentrantReadWriteLock 和StampedLock都是代码层面的锁定，要保证锁一定会被释放，就必须将unLock()放到final{}中。
synchronized放在函数或局部代码块中。
ReentrantLock是一个很好的通用的锁实现，适用于相对比较简单的加锁解锁的业务逻辑，如果实现复杂的锁机制，当线程增长能够预估时也是可以的。
ReentrantReadWriteLock对锁又进行了扩展，引入了read和write阻塞和并发机制，相对于ReentrantLock，他可以实现更复杂的锁机制，且并发性也更高些。
StampedLock又在Lock的基础上，实现了可以满足乐观锁和悲观锁等一些在读线程越来越多的业务场景，对吞吐量有巨大的改进，但并不是说要替代Lock，毕竟他还是有些应用场景的。
如果不是非得需要，应该尽量使用ReentrantLock和ReentrantReadWriteLock。

Lock和synchronized比较详解
https://www.cnblogs.com/handsomeye/p/5999362.html

Look/ReadWriteLock/AbstractQueuedSynchronizer----->ReetrantLock(Sync/NonfairSync)/ReentrantReadWriteLock/StampedLock(JDK8之后才有，当高并发下且读远大于写时，由于可以乐观读，性能极高！)

Volatile,Synchronized与Lock的区别？
Java内存模型规定所有的变量都是存在主存当中，每个线程都有自己的工作内存。Volatile：只能修饰变量，意思是把当前变量放入主内存区，每次变动都是操作主内存区。有三种特性：原子性（不允许出现i++）/可见性/有序性,不会阻塞线程, volatile标记的变量不会被编译器优化。

synchronized：可以使用在变量、方法、和类级别的，只有当前线程可以访问该变量，其他线程被阻塞住，原理是先自旋，再阻塞，线程处于blocked状态，不能响应中断，synchronized标记的变量可以被编译器优化，JVM会自动释放锁定。

Lock: 有公平/非公平策略, 有tryLock()，非阻塞方式, 有lockInterruptibly，可以响应中断, Lock对应的Condition，其使用方式要比Synchronized对应的wait()/notify()更加灵活。加锁后线程处于waiting状态，lock是通过代码实现解锁的，要保证锁定一定会被释放，就必须将unLock()放到finally{}中。

自旋锁spinlock剖析与改进---->互斥锁区别
https://blog.csdn.net/zorelemn/article/details/52685997

互斥锁和自旋锁的区别
https://blog.csdn.net/susidian/article/details/51068858
互斥锁：线程会从sleep（加锁）——>running（解锁），过程中有上下文的切换，cpu的抢占，信号的发送等开销，唤醒过程消耗巨大。
自旋锁：线程一直是running(加锁——>解锁)，死循环检测锁的标志位，机制不复杂，大量线程抢占过程中会消耗CPU巨大，一般用于多核的服务器。

ReentrantLock-->Sync--->公平和非公平策略(FairSync/NonfairSync)
ReentrantLock是以独占锁的加锁策略实现的互斥锁，同时它提供了公平(独占)和非公平(共享)两种锁获取方式。
独占锁 -- 锁在一个时间点只能被一个线程锁占有。根据锁的获取机制，它又划分为“公平锁”和“非公平锁”。公平锁，是按照通过CLH等待线程按照先来先得的规则，公平的获取锁；而非公平锁，则当线程要获取锁时，它会无视CLH等待队列而直接获取锁。独占锁的典型实例子是ReentrantLock，此外，ReentrantReadWriteLock.WriteLock也是独占锁。
共享锁 -- 能被多个线程同时拥有，能被共享的锁。JUC包中的ReentrantReadWriteLock.ReadLock，CyclicBarrier， CountDownLatch和Semaphore都是共享锁。

FairSync与NonfairSync-------->ReentrantLock的重入计数是使用AbstractQueuedSynchronizer的state属性的，state大于0表示锁被占用、等于0表示空闲，小于0则是重入次数太多导致溢出了
http://uule.iteye.com/blog/2120164

重入锁的理解
https://www.cnblogs.com/Andya/p/7272276.html

ReentrantReadWriteLock--->公平和非公平策略/读锁和写锁
https://www.cnblogs.com/zaizhoumo/p/7782941.html

JDK8并发包新增StampedLock锁
https://www.jianshu.com/p/481071ddafd3
信号量的含义---->以一个停车场的运作为例。简单起见，假设停车场只有三个车位，一开始三个车位都是空的。
				这时如果同时来了五辆车，看门人允许其中三辆直接进入，然后放下车拦，剩下的车则必须在入口等待，此后来的车也都不得不在入口处等待。
				这时，有一辆车离开停车场，看门人得知后，打开车拦，放入外面的一辆进去，如果又离开两辆，则又可以放入两辆，如此往复。
　　			在这个停车场系统中，车位是公共资源，每辆车好比一个线程，看门人起的就是信号量的作用。
https://blog.csdn.net/wxwzy738/article/details/8063632
《Java高并发程序设计》学习 --6.6 读写锁的改进：StampedLock
https://blog.csdn.net/sunhaoning/article/details/68924625


1、StampedLock是做什么的？
-----》它是ReentrantReadWriteLock 的增强版，是为了解决ReentrantReadWriteLock的一些不足。
2、ReentrantReadWriteLock有什么不足之处呢？
------》我们都知道，ReentrantReadWriteLock是读写锁，在多线程环境下，大多数情况是读的情况远远大于写的操作，因此可能导致写的饥饿问题。（换人话来说的话，读操作一直都能抢占到CPU时间片，而写操作一直抢不了）
3、为什么会导致写操作会出血饥饿问题呢？
-----》ReentrantReadWriteLock写锁的互斥的
（读和读---不互斥，读和写---互斥，写和写----互斥），懂了吗？
4、正因为ReentrantReadWriteLock出现了读和写是互斥的情况，这个地方需要优化，因此就出现了StampedLock！
5、StampedLock是读锁并不会阻塞写锁。这里就有朋友会问，如果这样设计的话，那么怎样保证读和写的一致性呢？
-----》StampedLock的设计思路也比较简单，就是在读的时候发现有写操作，再去读多一次。（思想上来说）
6、那下一个问题就是StampedLock是怎样知道读的时候发生了写操作呢？
-----》我们的StampedLock有两种锁，一种是悲观锁，另外一种是乐观锁。如果线程拿到乐观锁就读和写不互斥，如果拿到悲观锁就读和写互斥。
7、看StampedLock源码的时候，可以看writeLock()和trywriteLock(),tryOptimisticRead()这是本API中最有亮点的方法（乐观锁）。
http://blog.sina.com.cn/s/blog_6f5e71b30102xfsb.html



一、乐观锁
 总是认为不会产生并发问题，每次去取数据的时候总认为不会有其他线程对数据进行修改，因此不会上锁，但是在更新时会判断其他线程在这之前有没有对数据进行修改，一般会使用版本号机制或CAS操作实现。
 version方式：一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。
核心SQL代码：update table set x=x+1, version=version+1 where id=#{id} and version=#{version};  
 CAS操作方式：即compare and swap 或者 compare and set，涉及到三个操作数，数据所在的内存值，预期值，新值。当需要更新时，判断当前内存值与之前取到的值是否相等，若相等，则用新值更新，若失败则重试，一般情况下是一个自旋操作，即不断的重试。
一、悲观锁
 总是假设最坏的情况，每次取数据时都认为其他线程会修改，所以都会加锁（读锁、写锁、行锁等），当其他线程想要访问数据时，都需要阻塞挂起。可以依靠数据库实现，如行锁、读锁和写锁等，都是在操作之前加锁，在Java中，synchronized的思想也是悲观锁。
https://blog.csdn.net/L_BestCoder/article/details/79298417

--------------------------------------------------------------------------------------Condition-----------------------------------------

Condition的作用是对锁进行更精确的控制。Condition中的await()方法相当于Object的wait()方法，Condition中的signal()方法相当于Object的notify()方法，Condition中的signalAll()相当于Object的notifyAll()方法。
不同的是，Object中的wait(),notify(),notifyAll()方法是和"同步锁"(synchronized关键字)捆绑使用的；而Condition是需要与"互斥锁"/"共享锁"捆绑使用的
JUC 锁 - AQS - Condition
https://my.oschina.net/oxf1992/blog/843986

简述DCL失效原因，解决方法
https://blog.csdn.net/m_xiaoer/article/details/73480137



java.util.concurrent包下：
Semaphore（信号量）：


